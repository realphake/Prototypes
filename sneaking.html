<!DOCTYPE html>
<html lang="en"><body>

<script src="genericFunctions.js"></script>
<script>

var mouse = {
isDown: false,
justChanged: false,
wentDownAt: {x: 320, y: 240},
isNowAt: {x: 320, y: 240}
};

var handleMouseDown = function (e) {
mouse.isDown = true;
mouse.justChanged = true;
mouse.wentDownAt.x = e.pageX - canvas.offsetLeft;
mouse.wentDownAt.y = e.pageY - canvas.offsetTop;
};

var handleMouseUp = function (e) {
mouse.isDown = false;
mouse.justChanged = true;
};

var handleMouseMove = function (e) {
mouse.isNowAt.x = e.pageX - canvas.offsetLeft;
mouse.isNowAt.y = e.pageY - canvas.offsetTop;
};

var updateInput = function () {
mouse.justChanged = false;
};

canvas.addEventListener("mousedown", handleMouseDown, false);
canvas.addEventListener("mouseup", handleMouseUp, false);
canvas.addEventListener("mousemove", handleMouseMove, false);

var careful = 0; var reckless = 0;
var score = 0; var temporaryScore = 0;
var player = {x:630,y:470,gotoX:630,gotoY:470};
var enemies = [{x:15,y:10,gotoX:15,gotoY:10}];//,{x:10,y:15,gotoX:10,gotoY:15}];
var walls = [{x1:5,y1:5,x2:5,y2:475},{x1:5,y1:5,x2:635,y2:5},
		{x1:635,y1:5,x2:635,y2:475},{x1:5,y1:475,x2:635,y2:475}];
var weaponAngle = 0;
var weapon = {x1:0,y1:0,x2:0,y2:0};
var doors = [];
var reward = {x:20,y:20,radius:10};
for (var x = 0; x < 30; x++) placeBox();
var enemiesWaiting = [0,0];

function shootyTimes() {
	for ( var i = 0; i < enemies.length; i++ ) {
		if (oneWallCollision(enemies[i].x,enemies[i].y,player.x,player.y)) {
			enemiesWaiting[i] = 100;
		}
	}
}

function update () { 
	deltaX = 0; deltaY = 0;
	if (87 in keysDown) deltaY -= 4;
	if (83 in keysDown) deltaY += 4;
	if (65 in keysDown) deltaX -= 4;
	if (68 in keysDown) deltaX += 4;
	if (38 in keysDown) deltaY -= 4;
	if (40 in keysDown) deltaY += 4;
	if (37 in keysDown) deltaX -= 4;
	if (39 in keysDown) deltaX += 4;
	if (88 in keysDown) { }//shootyTimes(); }
	weaponAngle = angleOfLine(mouse.isNowAt.x,mouse.isNowAt.y,player.x,player.y);
	if ( deltaX != 0 && deltaY != 0 ) { deltaX *= 0.70710678118; deltaY *= 0.70710678118;}
	player.gotoY = player.gotoY + deltaY; player.gotoX = player.gotoX + deltaX;
	if (deltaX == 0 && deltaY == 0) careful += 0.01;
	else reckless += 0.01;
	if (lengthOfLine(player.x, player.y, reward.x, reward.y) < reward.radius) {
		careful += 100;
		reward.x = randomBetween(0,640); reward.y = randomBetween(0,480);
	}
	if (noWallCollisions(player.x,player.y,player.gotoX,player.gotoY) && ! (88 in keysDown) ) {
		player.x = player.gotoX; player.y = player.gotoY;
	}
	if (! (88 in keysDown)) {player.gotoX = player.x;player.gotoY = player.y; }
	var playerNotSeen = true;
	for ( var i = 0; i < enemies.length; i++ ) {
		var enemySpeed = 2;
		if (noWallCollisions(enemies[i].x,enemies[i].y,player.x,player.y)) {
			playerNotSeen = false;
			enemies[i].gotoX = player.x; enemies[i].gotoY = player.y; enemySpeed = 6;
			if (lengthOfLine(player.x,player.y, enemies[i].x,enemies[i].y) < 10) { 
				if (score == 0) score = careful+reckless; 
				careful = 0; reckless = 0;
			} else temporaryScore += 10;
		}
		var journeyLength = lengthOfLine(enemies[i].x,enemies[i].y,enemies[i].gotoX,enemies[i].gotoY);
		if ( journeyLength > enemySpeed ) {
			if (enemiesWaiting[i] > 0) {
				enemiesWaiting[i] -= 1;
			} else {
				// go partway to the destination
				var partOfLine = enemySpeed/journeyLength;
				enemies[i].x += (enemies[i].gotoX - enemies[i].x) * partOfLine;
				enemies[i].y += (enemies[i].gotoY - enemies[i].y) * partOfLine;
			}
		} else {
			// find a new destination
			var newX = randomBetween(0,640);
			var newY = randomBetween(0,480);
			while(true) {
				// Keep trying new places until we find one we can get to.
				if (noWallCollisions(enemies[i].x,enemies[i].y,newX,newY)) break;
				else {
					var newX = randomBetween(0,640);
					var newY = randomBetween(0,480);
				}
			}
			enemies[i].gotoX = newX; enemies[i].gotoY = newY;
		}
	}
	var aimingAt = lineFrom(player.x, player.y, 1000, weaponAngle);
	var intersect = ricochetPoint(aimingAt.x1, aimingAt.y1, aimingAt.x2, aimingAt.y2);
	//var wallAngle = angleOfLine(intersect.x1,intersect.y1,intersect.x2,intersect.y2);
	//var angleOfThatLine = wallAngle+Math.PI-(angleOfLine(player.x,player.y,intersect.x,intersect.y)-wallAngle);
	//var line = lineFrom(intersect.x,intersect.y,1000,angleOfThatLine);
	//var stopPoint = ricochetPoint(line.x1,line.y1,line.x2,line.y2);
	var stopPoint = ricochetPoint(intersect.x,intersect.y,aimingAt.x2,aimingAt.y2);
	weapon.x1 = player.x; weapon.y1 = player.y; weapon.x2 = stopPoint.x; weapon.y2 = stopPoint.y;
	
	if (playerNotSeen) { reckless += temporaryScore; temporaryScore = 0; }
}
function render () { 
	clear();
	fillCircle(reward.x,reward.y,reward.radius, "lightgreen");
	drawCircle(reward.x,reward.y,reward.radius, "green");
	for ( var i = 0; i < doors.length; i++ ) {
		drawLine(doors[i].x1, doors[i].y1, doors[i].x2, doors[i].y2,"lightgrey");
	}
	for ( var i = 0; i < walls.length; i++ ) {
		drawLine(walls[i].x1, walls[i].y1, walls[i].x2, walls[i].y2,"black");
	}
	var color = "black";
	if (noWallCollisions(player.x,player.y,player.gotoX,player.gotoY)) color = "lightblue";
	else color = "red";
	fillBox(player.gotoX-10, player.gotoY-10, 20,20, "lightblue");
	fillBox(player.x-10, player.y-10, 20,20, "blue");
	drawLine(player.x,player.y,player.gotoX,player.gotoY, color)
	for ( var i = 0; i < enemies.length; i++ ) {
		var color = colorForLineOfSight(enemies[i]);
		var color2 = "lightblue";
		var color2 = colorForWeapon(enemies[i]);
		drawLine(enemies[i].x, enemies[i].y, player.x, player.y, color2);
		fillBox(enemies[i].x-10, enemies[i].y-10, 20,20, color);
		
		//drawLine(player.x, player.y,weapon.x1, weapon.y1, "red");
		//drawLine(weapon.x1, weapon.y1,weapon.x2, weapon.y2, "red");
	}
	if (score > 0) {
		writeText("final score: "+Math.floor(score),320,240, "green");
		writeText("Reload the page to try again.",320,255, "green");
	} else writeText("Score: "+Math.floor(careful+reckless),5,15, "green");
	
}

function colorForWeapon(enemy) {
	var color = "black";
	if (oneWallCollision(enemy.x,enemy.y,player.x,player.y)) color = "red";
	else color = "lightblue";
	return color;
}

function lineFrom(startX,startY,length,angle) {
	var output = {};
	output.x2 = Math.cos(angle) * length; output.y2 = Math.sin(angle) * length;
	output.x2 += startX; output.y2 += startY;
	output.x1 = startX; output.y1 = startY;
	return output;
}

function placeBox () {
	rot = randomBetween(0, Math.PI*2);
	scale = randomBetween(20,50);
	var right = {x:Math.cos(rot),y:Math.sin(rot)}; var top = {x:Math.cos(rot+Math.PI*1.5),y:Math.sin(rot+Math.PI*1.5)}; 
	var bottom = {x:Math.cos(rot+Math.PI/2),y:Math.sin(rot+Math.PI/2)}; var left = {x:Math.cos(rot+Math.PI),y:Math.sin(rot+Math.PI)};
	var center = {x:randomBetween(0,640),y:randomBetween(0,480)};
	doors.push({x1:bottom.x*scale+center.x,y1:bottom.y*scale+center.y,x2:right.x*scale+center.x,y2:right.y*scale+center.y});
	walls.push({x1:right.x*scale+center.x,y1:right.y*scale+center.y,x2:top.x*scale+center.x,y2:top.y*scale+center.y});
	walls.push({x1:top.x*scale+center.x,y1:top.y*scale+center.y,x2:left.x*scale+center.x,y2:left.y*scale+center.y});
	walls.push({x1:bottom.x*scale+center.x,y1:bottom.y*scale+center.y,x2:left.x*scale+center.x,y2:left.y*scale+center.y});
}

function ricochetPoint(x1,y1,x2,y2) {
	var length = 1000;
	var found = {x:1,y:1, x1:0,y1:0,x2:0,y2:0};
	for ( var j = 0; j < walls.length; j++ ) { 
		var i = checkLineIntersection(x1,y1,x2,y2, walls[j].x1,walls[j].y1,walls[j].x2,walls[j].y2);
		if ( i.onLine1 && i.onLine2 ) {
			if (lengthOfLine(x1,y1,i.x,i.y) < length) {
				found.x = i.x; found.y = i.y;
				found.x1 = walls[j].x1; found.y1 = walls[j].y1;
				found.x2 = walls[j].x2; found.y2 = walls[j].y2;
				length = lengthOfLine(x1,y1,i.x,i.y);
			}
		}
	}
	return found;
}

function colorForLineOfSight(enemy) {
	var color = "black";
	if (noWallCollisions(enemy.x,enemy.y,player.x,player.y)) color = "red";
	else color = "orange";
	return color;
}

function noWallCollisions(x1,y1,x2,y2) {
	for ( var j = 0; j < walls.length; j++ ) { 
		var intersection = checkLineIntersection(x1,y1,x2,y2, walls[j].x1,walls[j].y1,walls[j].x2,walls[j].y2);
		if ( intersection.onLine1 && intersection.onLine2 ) return false; 
	}
	return true;
}
function oneWallCollision(x1,y1,x2,y2) {
	var collisions = 0;
	for ( var j = 0; j < walls.length; j++ ) { 
		var intersection = checkLineIntersection(x1,y1,x2,y2, walls[j].x1,walls[j].y1,walls[j].x2,walls[j].y2);
		if ( intersection.onLine1 && intersection.onLine2 ) collisions += 1; 
	}
	if ( collisions <= 1 ) return true;
	else return false;
}
setInterval(function () { update(); render(); }, 20);
</script>

</body></html>

<!DOCTYPE html>
<html lang="en"><body>

<script src="genericFunctions.js"></script>
<script>

var player = {x:50,y:50,gotoX:50,gotoY:50,radius:8,dead:false};
var dashLength = 100;
var dashMax = 100;
var enemies = [];
var walls = [];
var reward = {x:20,y:20,radius:10,taken:30, seen:false};
var levelMap = 0;
var map = [];

var hungry = 100;

var hormap = 41;
var vertmap = 31;
var gridsz=16;
var viewDistance = 100;

var march = 0;

createLevel();

function imageFrom(filename) {
	result = new Image();
	result.onLoad = function () {console.log("done loading.");}
	result.src = filename;
	return result;
}

function createLevel() {
	
	map = new Array(hormap);
	for (var x = 0; x < hormap; x++) {
		map[x] = new Array(vertmap);
		for (var y = 0; y < vertmap; y++) {
			map[x][y] = 1;
		}
	}
	var drunkX = Math.round(randomBetween(1,hormap-1));
	var drunkY = Math.round(randomBetween(1,vertmap-1));
	player.x = (drunkX+0.5)*gridsz; player.y = (drunkY+0.5)*gridsz;
	player.gotoX = (drunkX+0.5)*gridsz; player.gotoY = (drunkY+0.5)*gridsz;
	map[drunkX][drunkY] = 0;
	var amountOfMapWalkable = 1;
	while(true) {
		if (randomDouble () < 0.5) drunkX += Math.round (randomDouble () ) * 2 - 1;
		else drunkY += Math.round (randomDouble () ) * 2 - 1;
		if ( drunkX <= 0 ) drunkX+=1; if ( drunkX >= hormap-1 ) drunkX-=1;
		if ( drunkY <= 0 ) drunkY+=1; if ( drunkY >= vertmap-1 ) drunkY-=1;
		if (map[drunkX][drunkY] == 1) {
			map[drunkX][drunkY] = 0; amountOfMapWalkable+=1;
			if (lengthOfLine((drunkX+0.5)*gridsz, (drunkY+0.5)*gridsz, player.x,player.y) > viewDistance * 2) {
				if (randomDouble() < 0.02) 
					enemies.push({x:(drunkX+0.5)*gridsz, 
						y:(drunkY+0.5)*gridsz,
						gotoX:(drunkX+0.5)*gridsz, 
						gotoY:(drunkY+0.5)*gridsz,
						radius:8});
			}
		}
		if ( amountOfMapWalkable >= (hormap*vertmap)/3 ) break;
	}
	
	for (var x = 0; x < hormap-1; x++) {
		for (var y = 0; y < vertmap-1; y++) {
			var totalWalkable = map[x][y] + map[x+1][y+1] + map[x+1][y] + map[x][y+1];
			if ( totalWalkable == 1 || totalWalkable == 3 ) { // SOME CORNER
				if ( map[x][y] != map[x+1][y] && map[x][y] != map[x][y+1] ) // LEFT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y+1] != map[x+1][y] && map[x+1][y+1] != map[x][y+1] ) // RIGHT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y] != map[x+1][y+1] && map[x+1][y] != map[x][y] ) // RIGHT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x][y+1] != map[x+1][y+1] && map[x][y+1] != map[x][y] ) // LEFT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
			}
			if ( totalWalkable == 2 ) {
				if ( map[x][y] == map[x+1][y+1] ) { // DIAGONAL 
					if ( map[x][y] == 1 ) {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
					} else {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
					}
				}
				else { // STRAIGHT
					if ( map[x][y] == map[x][y+1] ) // VERTICAL
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+0.5)*gridsz,y2:(y)*gridsz});
					else // HORIZONTAL
						walls.push({x1:(x+1)*gridsz,y1:(y+0.5)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				}
			}
		}
	}
	
	levelMap = map;
	
	march = imageFrom("marchingsquares.png");

}

function update () { 
	deltaX = 0; deltaY = 0;
	if (87 in keysDown) deltaY -= 4;
	if (83 in keysDown) deltaY += 4;
	if (65 in keysDown) deltaX -= 4;
	if (68 in keysDown) deltaX += 4;
	if (38 in keysDown) deltaY -= 4;
	if (40 in keysDown) deltaY += 4;
	if (37 in keysDown) deltaX -= 4;
	if (39 in keysDown) deltaX += 4;
	if ( deltaX != 0 && deltaY != 0 ) { deltaX *= 0.70710678118; deltaY *= 0.70710678118;}
	if ( lengthOfLine( player.x, player.y, player.gotoX + deltaX, player.gotoY + deltaY ) <= dashLength && !player.dead ) {
		player.gotoY = player.gotoY + deltaY; player.gotoX = player.gotoX + deltaX;
	}
	if (lengthOfLine(player.x, player.y, reward.x, reward.y) < reward.radius+player.radius && ! (88 in keysDown) && !player.dead ) {
		if (reward.taken < 0) { reward.taken = 30; reward.x = randomBetween(0,640); reward.y = randomBetween(0,480); } 
		else { reward.taken -= 1; }
	}
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY}) && ! (88 in keysDown) && !player.dead ) {
		var movedThisTic = lengthOfLine(player.x, player.y, player.gotoX, player.gotoY );
		dashLength -= movedThisTic;
		player.x = player.gotoX; player.y = player.gotoY;
		dashLength += Math.min(movedThisTic,4-0.25);
	}
	if (! (88 in keysDown) && !player.dead) {player.gotoX = player.x;player.gotoY = player.y;dashLength+=0.25; hungry -= 0.01 }
	if (hungry < 0) hungry = 0;
	if (dashLength > dashMax) dashLength = dashMax;
	if (! (88 in keysDown)) {
		for ( var i = 0; i < enemies.length; i++ ) {
			var enemySpeed = 1;
			if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:player.x,y2:player.y}) && lengthOfLine(enemies[i].x,enemies[i].y,player.x,player.y) < viewDistance-player.radius && !player.dead) {
				enemies[i].gotoX = player.x; enemies[i].gotoY = player.y; enemySpeed = 5;
			}
			var journeyLength = lengthOfLine(enemies[i].x,enemies[i].y,enemies[i].gotoX,enemies[i].gotoY);
			if ( journeyLength > enemySpeed ) {
				// go partway to the destination
				var partOfLine = enemySpeed/journeyLength;
				enemies[i].x += (enemies[i].gotoX - enemies[i].x) * partOfLine;
				enemies[i].y += (enemies[i].gotoY - enemies[i].y) * partOfLine;
			} else {
				// find a new destination
				var newX = randomBetween(0,640);
				var newY = randomBetween(0,480);
				while(true) {
					// Keep trying new places until we find one we can get to.
					if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:newX,y2:newY})) break;
					else {
						var newX = randomBetween(0,640);
						var newY = randomBetween(0,480);
					}
				}
				enemies[i].gotoX = newX; enemies[i].gotoY = newY;
			}
		}
	}
	for ( var i = 0; i < enemies.length; i++ ) {
		if (hungry <= 0 || lengthOfLine(enemies[i].x,enemies[i].y,player.x,player.y) < enemies[i].radius+player.radius) {
			player.dead = true;
		}
	}
}

function render () { 
	clear();
	fillBox(0,0,640,480,"black");
	for ( var i = 0; i < enemies.length; i++ ) {
		fillBox(0,0,640,480,"black", true);
		tempContext.globalCompositeOperation="destination-out";
		fillCircle(enemies[i].x,enemies[i].y,viewDistance,"black", true);
		tempContext.globalCompositeOperation="source-over";
		for ( var j = 0; j < walls.length; j++ ) {
			if (lengthOfLine(walls[j].x1, walls[j].y1, enemies[i].x, enemies[i].y) < viewDistance ||
					lengthOfLine(walls[j].x2, walls[j].y2, enemies[i].x, enemies[i].y) < viewDistance)
				drawShadow(enemies[i].x, enemies[i].y, walls[j].x1, walls[j].y1, walls[j].x2, walls[j].y2);
		}
		deployChanges("source-in",1);
	}
	
	for (var x = 0; x < hormap-1; x++) {
		for (var y = 0; y < vertmap-1; y++) {
			var number = levelMap[x][y]*1+levelMap[x+1][y]*2+levelMap[x+1][y+1]*4+levelMap[x][y+1]*8;
			var sy = Math.floor(number/4);
			var sx = number - sy*4;
			drawImage(march, x*gridsz,y*gridsz, gridsz,gridsz, sx*16,sy*16, 16,16, true);
		}
	}
	deployChanges("source-over", 0.5);
	
	if (noWallCollisions({x1:player.x,y1:player.y,x2:reward.x,y2:reward.y})) { reward.seen = true; }
	if (reward.seen) {
		fillCircle(reward.x,reward.y,reward.radius, "lightgreen");
		drawCircle(reward.x,reward.y,reward.radius, "green");
	}
	fillCircle(player.gotoX, player.gotoY, player.radius, "lightblue");
	drawCircle(player.x,player.y,dashLength, "blue");
	fillCircle(player.x, player.y, player.radius, "blue");
	var color = "black";
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY})) color = "lightblue";
	else color = "red";
	drawLine(player.x,player.y,player.gotoX,player.gotoY, color);
	for ( var i = 0; i < enemies.length; i++ ) {
		fillCircle(enemies[i].x, enemies[i].y, enemies[i].radius, "red");
	}
	
	fillBox(5,5,6.30*hungry,5,"orange");
	if (player.dead) {
		context.globalAlpha = 0.3;fillBox(0,0,640,480,"red");context.globalAlpha = 1;
		writeText("You have died!",320,240, "red");
	}
	
}

function drawShadow(lightX, lightY, wallX1, wallY1, wallX2, wallY2) {
	var angle1 = angleOfLine( wallX1,wallY1,lightX,lightY);
	var angle2 = angleOfLine( wallX2,wallY2,lightX,lightY);
	var line1 = lineFrom(wallX1,wallY1,1000,angle1);
	var line2 = lineFrom(wallX2,wallY2,1000,angle2);
	fillQuadrilateral(line1.x1,line1.y1,line1.x2,line1.y2,line2.x2,line2.y2,line2.x1,line2.y1, "black", true);
	drawQuadrilateral(line1.x1,line1.y1,line1.x2,line1.y2,line2.x2,line2.y2,line2.x1,line2.y1, "black", true);	
}

function noWallCollisions(line) {
	for ( var j = 0; j < walls.length; j++ ) { 
		var intersection = checkLineIntersection(line, walls[j]);
		if ( intersection.onLine1 && intersection.onLine2 ) return false; 
	}
	return true;
}

setInterval(function () { update(); render(); }, 20);
</script>

<p>Use the arrow keys to move; use the X key to dash.</p>

</body></html>

<!DOCTYPE html>
<html lang="en"><body>

<script src="genericFunctions.js"></script>
<script>

var careful = 0; var reckless = 0;
var score = 0; var temporaryScore = 0;
var player = {x:50,y:50,gotoX:50,gotoY:50};
var dashLength = 100;
var dashMax = 100;
var enemies = [{x:320,y:240,gotoX:320,gotoY:240},{x:320,y:240,gotoX:320,gotoY:240}];
var viewDistance = 200;
var walls = [{x1:5,y1:5,x2:5,y2:475},{x1:5,y1:5,x2:635,y2:5},
		{x1:635,y1:5,x2:635,y2:475},{x1:5,y1:475,x2:635,y2:475}];
var weaponAngle = 0;
var weapon = {x1:0,y1:0,x2:0,y2:0};
var doors = [];
var reward = {x:20,y:20,radius:10,taken:30};
var levelMap = 0;
createLevel();
var enemiesWaiting = [0,0];

var tempCanvas = document.createElement('canvas');
tempCanvas.width = 640;
tempCanvas.height = 480;
var tempContext = tempCanvas.getContext('2d');

function createLevel() {
	var hormap = 14;
	var vertmap = 11;
	var map = new Array(hormap);
	for (var x = 0; x < hormap; x++) {
		map[x] = new Array(vertmap);
		for (var y = 0; y < vertmap; y++) {
			map[x][y] = Math.round( randomBetween(0,1) );
		}
	}
	var gridsz=50;
	
	for (var x = 0; x < hormap-1; x++) {
		for (var y = 0; y < vertmap-1; y++) {
			var totalWalkable = map[x][y] + map[x+1][y+1] + map[x+1][y] + map[x][y+1];
			if ( totalWalkable == 1 || totalWalkable == 3 ) { // SOME CORNER
				if ( map[x][y] != map[x+1][y] && map[x][y] != map[x][y+1] ) // LEFT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y+1] != map[x+1][y] && map[x+1][y+1] != map[x][y+1] ) // RIGHT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y] != map[x+1][y+1] && map[x+1][y] != map[x][y] ) // RIGHT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x][y+1] != map[x+1][y+1] && map[x][y+1] != map[x][y] ) // LEFT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
			}
			if ( totalWalkable == 2 ) {
				if ( map[x][y] == map[x+1][y+1] ) { // DIAGONAL 
					if ( map[x][y] == 1 ) {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
					} else {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
					}
				}
				else { // STRAIGHT
					if ( map[x][y] == map[x][y+1] ) // VERTICAL
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+0.5)*gridsz,y2:(y)*gridsz});
					else // HORIZONTAL
						walls.push({x1:(x+1)*gridsz,y1:(y+0.5)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				}
			}
		}
	}
	
	levelMap = map;

}

function shootyTimes() {
	for ( var i = 0; i < enemies.length; i++ ) {
		if (oneWallCollision(enemies[i].x,enemies[i].y,player.x,player.y)) {
			enemiesWaiting[i] = 100;
		}
	}
}

function update () { 
	deltaX = 0; deltaY = 0;
	if (87 in keysDown) deltaY -= 4;
	if (83 in keysDown) deltaY += 4;
	if (65 in keysDown) deltaX -= 4;
	if (68 in keysDown) deltaX += 4;
	if (38 in keysDown) deltaY -= 4;
	if (40 in keysDown) deltaY += 4;
	if (37 in keysDown) deltaX -= 4;
	if (39 in keysDown) deltaX += 4;
	if ( deltaX != 0 && deltaY != 0 ) { deltaX *= 0.70710678118; deltaY *= 0.70710678118;}
	if ( lengthOfLine( player.x, player.y, player.gotoX + deltaX, player.gotoY + deltaY ) <= dashLength ) {
		player.gotoY = player.gotoY + deltaY; player.gotoX = player.gotoX + deltaX;
	}
	if (deltaX == 0 && deltaY == 0) careful += 0.01;
	else reckless += 0.01;
	if (lengthOfLine(player.x, player.y, reward.x, reward.y) < reward.radius ) {
		if (reward.taken < 0) {
			careful += 100; reward.taken = 30;
			reward.x = randomBetween(0,640); reward.y = randomBetween(0,480);
		} else {
			reward.taken -= 1;
		}
	}
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY}) && ! (88 in keysDown) ) {
		var movedThisTic = lengthOfLine(player.x, player.y, player.gotoX, player.gotoY );
		dashLength -= movedThisTic;
		player.x = player.gotoX; player.y = player.gotoY;
		dashLength += Math.min(movedThisTic,4-0.25);
	}
	if (! (88 in keysDown)) {player.gotoX = player.x;player.gotoY = player.y;dashLength+=0.25; }
	if (dashLength > dashMax) dashLength = dashMax;
	var playerNotSeen = true;
	if (! (88 in keysDown)) {
		for ( var i = 0; i < enemies.length; i++ ) {
			var enemySpeed = 1;
			if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:player.x,y2:player.y}) && lengthOfLine(enemies[i].x,enemies[i].y,player.x,player.y) < viewDistance) {
				playerNotSeen = false;
				enemies[i].gotoX = player.x; enemies[i].gotoY = player.y; enemySpeed = 5;
				if (lengthOfLine(player.x,player.y, enemies[i].x,enemies[i].y) < 10) { 
					if (score == 0) score = careful+reckless; 
					careful = 0; reckless = 0;
				} else temporaryScore += 10;
			}
			var journeyLength = lengthOfLine(enemies[i].x,enemies[i].y,enemies[i].gotoX,enemies[i].gotoY);
			if ( journeyLength > enemySpeed ) {
				if (enemiesWaiting[i] > 0) {
					enemiesWaiting[i] -= 1;
				} else {
					// go partway to the destination
					var partOfLine = enemySpeed/journeyLength;
					enemies[i].x += (enemies[i].gotoX - enemies[i].x) * partOfLine;
					enemies[i].y += (enemies[i].gotoY - enemies[i].y) * partOfLine;
				}
			} else {
				// find a new destination
				var newX = randomBetween(0,640);
				var newY = randomBetween(0,480);
				while(true) {
					// Keep trying new places until we find one we can get to.
					if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:newX,y2:newY})) break;
					else {
						var newX = randomBetween(0,640);
						var newY = randomBetween(0,480);
					}
				}
				enemies[i].gotoX = newX; enemies[i].gotoY = newY;
			}
		}
	}
	
	if (playerNotSeen) { reckless += temporaryScore; temporaryScore = 0; }
}
function render () { 
	clear();
	context.strokeStyle = "lightgrey"; context.fillStyle = "lightgrey";
	context.fillRect(0,0,640,480); 
	context.fillStyle = "black"; context.strokeStyle = "black";
	
	for ( var i = 0; i < enemies.length; i++ ) {
		tempContext.strokeStyle = "lightgrey"; tempContext.fillStyle = "lightgrey";
		tempContext.fillRect(0,0,640,480); 
		tempContext.globalCompositeOperation="destination-out";
		tempContext.beginPath();
		tempContext.arc(enemies[i].x,enemies[i].y,viewDistance,0,2*Math.PI);
		tempContext.fill();
		tempContext.fillStyle = "black"; tempContext.strokeStyle = "black";
		tempContext.globalCompositeOperation="source-over";
		
		for ( var j = 0; j < walls.length; j++ ) {
			drawShadow(enemies[i].x, enemies[i].y, walls[j].x1, walls[j].y1, walls[j].x2, walls[j].y2);
		}
		
		context.globalCompositeOperation="source-in";
		context.drawImage(tempCanvas, 0, 0);
		context.globalCompositeOperation="source-over";
		tempCanvas.width = tempCanvas.width; 
	}
	for ( var i = 0; i < doors.length; i++ ) {
		drawLine(doors[i].x1, doors[i].y1, doors[i].x2, doors[i].y2,"lightgrey");
	}
	for ( var i = 0; i < walls.length; i++ ) {
		drawLine(walls[i].x1, walls[i].y1, walls[i].x2, walls[i].y2,"black");
	}
	var color = "black";
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY})) color = "lightblue";
	else color = "red";
	fillCircle(reward.x,reward.y,reward.radius, "lightgreen");
	drawCircle(reward.x,reward.y,reward.radius, "green");
	fillBox(player.gotoX-10, player.gotoY-10, 20,20, "lightblue");
	drawCircle(player.x,player.y,dashLength, "red");
	fillBox(player.x-10, player.y-10, 20,20, "blue");
	drawLine(player.x,player.y,player.gotoX,player.gotoY, color)
	for ( var i = 0; i < enemies.length; i++ ) {
		var color = colorForLineOfSight(enemies[i]);
		var color2 = "lightblue";
		drawLine(enemies[i].x, enemies[i].y, player.x, player.y, color2);
		fillBox(enemies[i].x-10, enemies[i].y-10, 20,20, color);
	}
	if (score > 0) {
		writeText("final score: "+Math.floor(score),320,240, "green");
		writeText("Reload the page to try again.",320,255, "green");
	} else writeText("Score: "+Math.floor(careful+reckless),5,15, "green");
	
}

function drawShadow(lightX, lightY, wallX1, wallY1, wallX2, wallY2) {
	var angle1 = angleOfLine( wallX1,wallY1,lightX,lightY);
	var angle2 = angleOfLine( wallX2,wallY2,lightX,lightY);
	var line1 = lineFrom(wallX1,wallY1,1000,angle1);
	var line2 = lineFrom(wallX2,wallY2,1000,angle2);
	tempContext.beginPath(); tempContext.strokeStyle = "lightgrey"; tempContext.fillStyle = "lightgrey";
	tempContext.moveTo(wallX1,wallY1);
	tempContext.lineTo(line1.x2,line1.y2);
	tempContext.lineTo(line2.x2,line2.y2);
	tempContext.lineTo(wallX2,wallY2);
	tempContext.lineTo(wallX1,wallY1);
	tempContext.fill(); tempContext.fillStyle = "black"; tempContext.strokeStyle = "black";
}

function colorForLineOfSight(enemy) {
	var color = "black";
	if (noWallCollisions( {x1:enemy.x,y1:enemy.y,x2:player.x,y2:player.y} )) color = "red";
	else color = "orange";
	return color;
}

function noWallCollisions(line) {
	for ( var j = 0; j < walls.length; j++ ) { 
		var intersection = checkLineIntersection(line, walls[j]);
		if ( intersection.onLine1 && intersection.onLine2 ) return false; 
	}
	return true;
}

setInterval(function () { update(); render(); }, 20);
</script>

<p>Use the arrow keys to move; use the X key to dash.</p>

</body></html>

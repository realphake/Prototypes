<!DOCTYPE html>
<html lang="en"><body>

<script src="genericFunctions.js"></script>
<script>

var careful = 0; var reckless = 0;
var score = 0; var temporaryScore = 0;
var player = {x:50,y:50,gotoX:50,gotoY:50};
var dashLength = 100;
var dashMax = 100;
var enemies = [{x:300,y:300,gotoX:300,gotoY:300},{x:310,y:310,gotoX:310,gotoY:310}];
var walls = [];
var weaponAngle = 0;
var weapon = {x1:0,y1:0,x2:0,y2:0};
var weapon = {x1:0,y1:0,x2:0,y2:0};
var reward = {x:20,y:20,radius:10,taken:30};
var levelMap = 0;

var hormap = 41;
var vertmap = 31;
var gridsz=16;
var viewDistance = 100;

var march = 0;

createLevel();

function imageFrom(filename) {
	result = new Image();
	result.onLoad = function () {console.log("done loading.");}
	result.src = filename;
	return result;
}

function createLevel() {
	
	var rawmap = new Array(hormap);
	for (var x = 0; x < hormap; x++) {
		rawmap[x] = new Array(vertmap);
		for (var y = 0; y < vertmap; y++) {
			rawmap[x][y] = Math.round( randomBetween(0,1) );
		}
	}
	
	var map = new Array(hormap);
	for (var x = 0; x < hormap; x++) {
		map[x] = new Array(vertmap);
		for (var y = 0; y < vertmap; y++) {
			if (x == 0 || y == 0 || x == hormap-1 || y == vertmap-1) {map[x][y] = 1; continue;}
			var count = rawmap[x+1][y]+rawmap[x-1][y]+rawmap[x][y+1]+rawmap[x][y-1] +
					rawmap[x+1][y+1]+rawmap[x-1][y-1]+rawmap[x-1][y+1]+rawmap[x+1][y-1];
			if ( count < 4 ) map[x][y] = 0;
			if ( count > 5 ) map[x][y] = 1;
			if ( count == 4 || count == 5 ) map[x][y] = rawmap[x][y];
		}
	}
	
	for (var x = 0; x < hormap-1; x++) {
		for (var y = 0; y < vertmap-1; y++) {
			var totalWalkable = map[x][y] + map[x+1][y+1] + map[x+1][y] + map[x][y+1];
			if ( totalWalkable == 1 || totalWalkable == 3 ) { // SOME CORNER
				if ( map[x][y] != map[x+1][y] && map[x][y] != map[x][y+1] ) // LEFT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y+1] != map[x+1][y] && map[x+1][y+1] != map[x][y+1] ) // RIGHT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x+1][y] != map[x+1][y+1] && map[x+1][y] != map[x][y] ) // RIGHT-UP
					walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
				else if ( map[x][y+1] != map[x+1][y+1] && map[x][y+1] != map[x][y] ) // LEFT-DOWN
					walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
			}
			if ( totalWalkable == 2 ) {
				if ( map[x][y] == map[x+1][y+1] ) { // DIAGONAL 
					if ( map[x][y] == 1 ) {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
					} else {
						walls.push({x1:(x+0.5)*gridsz,y1:(y)*gridsz,x2:(x+1)*gridsz,y2:(y+0.5)*gridsz});
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
					}
				}
				else { // STRAIGHT
					if ( map[x][y] == map[x][y+1] ) // VERTICAL
						walls.push({x1:(x+0.5)*gridsz,y1:(y+1)*gridsz,x2:(x+0.5)*gridsz,y2:(y)*gridsz});
					else // HORIZONTAL
						walls.push({x1:(x+1)*gridsz,y1:(y+0.5)*gridsz,x2:(x)*gridsz,y2:(y+0.5)*gridsz});
				}
			}
		}
	}
	
	levelMap = map;
	
	march = imageFrom("marchingsquares.png");

}

function update () { 
	deltaX = 0; deltaY = 0;
	if (87 in keysDown) deltaY -= 4;
	if (83 in keysDown) deltaY += 4;
	if (65 in keysDown) deltaX -= 4;
	if (68 in keysDown) deltaX += 4;
	if (38 in keysDown) deltaY -= 4;
	if (40 in keysDown) deltaY += 4;
	if (37 in keysDown) deltaX -= 4;
	if (39 in keysDown) deltaX += 4;
	if ( deltaX != 0 && deltaY != 0 ) { deltaX *= 0.70710678118; deltaY *= 0.70710678118;}
	if ( lengthOfLine( player.x, player.y, player.gotoX + deltaX, player.gotoY + deltaY ) <= dashLength ) {
		player.gotoY = player.gotoY + deltaY; player.gotoX = player.gotoX + deltaX;
	}
	if (deltaX == 0 && deltaY == 0) careful += 0.01;
	else reckless += 0.01;
	if (lengthOfLine(player.x, player.y, reward.x, reward.y) < reward.radius ) {
		if (reward.taken < 0) {
			careful += 100; reward.taken = 30;
			reward.x = randomBetween(0,640); reward.y = randomBetween(0,480);
		} else {
			reward.taken -= 1;
		}
	}
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY}) && ! (88 in keysDown) ) {
		var movedThisTic = lengthOfLine(player.x, player.y, player.gotoX, player.gotoY );
		dashLength -= movedThisTic;
		player.x = player.gotoX; player.y = player.gotoY;
		dashLength += Math.min(movedThisTic,4-0.25);
	}
	if (! (88 in keysDown)) {player.gotoX = player.x;player.gotoY = player.y;dashLength+=0.25; }
	if (dashLength > dashMax) dashLength = dashMax;
	var playerNotSeen = true;
	if (! (88 in keysDown)) {
		for ( var i = 0; i < enemies.length; i++ ) {
			var enemySpeed = 1;
			if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:player.x,y2:player.y}) && lengthOfLine(enemies[i].x,enemies[i].y,player.x,player.y) < viewDistance) {
				playerNotSeen = false;
				enemies[i].gotoX = player.x; enemies[i].gotoY = player.y; enemySpeed = 5;
				if (lengthOfLine(player.x,player.y, enemies[i].x,enemies[i].y) < 10) { 
					if (score == 0) score = careful+reckless; 
					careful = 0; reckless = 0;
				} else temporaryScore += 10;
			}
			var journeyLength = lengthOfLine(enemies[i].x,enemies[i].y,enemies[i].gotoX,enemies[i].gotoY);
			if ( journeyLength > enemySpeed ) {
				// go partway to the destination
				var partOfLine = enemySpeed/journeyLength;
				enemies[i].x += (enemies[i].gotoX - enemies[i].x) * partOfLine;
				enemies[i].y += (enemies[i].gotoY - enemies[i].y) * partOfLine;
			} else {
				// find a new destination
				var newX = randomBetween(0,640);
				var newY = randomBetween(0,480);
				while(true) {
					// Keep trying new places until we find one we can get to.
					if (noWallCollisions({x1:enemies[i].x,y1:enemies[i].y,x2:newX,y2:newY})) break;
					else {
						var newX = randomBetween(0,640);
						var newY = randomBetween(0,480);
					}
				}
				enemies[i].gotoX = newX; enemies[i].gotoY = newY;
			}
		}
	}
	
	if (playerNotSeen) { reckless += temporaryScore; temporaryScore = 0; }
}

function render () { 
	clear();
	
	fillBox(0,0,640,480,"black");
	
	for ( var i = 0; i < enemies.length; i++ ) {
		fillBox(0,0,640,480,"black", true);
		tempContext.globalCompositeOperation="destination-out";
		fillCircle(enemies[i].x,enemies[i].y,viewDistance,"black", true);
		tempContext.globalCompositeOperation="source-over";
		for ( var j = 0; j < walls.length; j++ ) {
			if (lengthOfLine(walls[j].x1, walls[j].y1, enemies[i].x, enemies[i].y) < viewDistance ||
					lengthOfLine(walls[j].x2, walls[j].y2, enemies[i].x, enemies[i].y) < viewDistance)
				drawShadow(enemies[i].x, enemies[i].y, walls[j].x1, walls[j].y1, walls[j].x2, walls[j].y2);
		}
		
		deployChanges("source-in",1);
	}
	
	for (var x = 0; x < hormap-1; x++) {
		for (var y = 0; y < vertmap-1; y++) {
			var number = levelMap[x][y]*1+levelMap[x+1][y]*2+levelMap[x+1][y+1]*4+levelMap[x][y+1]*8;
			var sy = Math.floor(number/4);
			var sx = number - sy*4;
			
			drawImage(march, x*gridsz,y*gridsz, gridsz,gridsz, sx*16,sy*16, 16,16, true);
		}
	}
	deployChanges("source-over", 0.5);
	
	var color = "black";
	if (noWallCollisions({x1:player.x,y1:player.y,x2:player.gotoX,y2:player.gotoY})) color = "lightblue";
	else color = "red";
	fillCircle(reward.x,reward.y,reward.radius, "lightgreen");
	drawCircle(reward.x,reward.y,reward.radius, "green");
	fillBox(player.gotoX-10, player.gotoY-10, 20,20, "lightblue");
	drawCircle(player.x,player.y,dashLength, "red");
	fillBox(player.x-10, player.y-10, 20,20, "blue");
	drawLine(player.x,player.y,player.gotoX,player.gotoY, color)
	for ( var i = 0; i < enemies.length; i++ ) {
		var color2 = "lightblue";
		fillBox(enemies[i].x-10, enemies[i].y-10, 20,20, "red");
	}
	if (score > 0) {
		writeText("final score: "+Math.floor(score),320,240, "green");
		writeText("Reload the page to try again.",320,255, "green");
	} else writeText("Score: "+Math.floor(careful+reckless),5,15, "green");
	
}

function drawShadow(lightX, lightY, wallX1, wallY1, wallX2, wallY2) {
	var angle1 = angleOfLine( wallX1,wallY1,lightX,lightY);
	var angle2 = angleOfLine( wallX2,wallY2,lightX,lightY);
	var line1 = lineFrom(wallX1,wallY1,1000,angle1);
	var line2 = lineFrom(wallX2,wallY2,1000,angle2);
	fillQuadrilateral(line1.x1,line1.y1,line1.x2,line1.y2,line2.x2,line2.y2,line2.x1,line2.y1, "black", true);	
}

function colorForLineOfSight(enemy) {
	var color = "black";
	if (noWallCollisions( {x1:enemy.x,y1:enemy.y,x2:player.x,y2:player.y} )) color = "red";
	else color = "orange";
	return color;
}

function noWallCollisions(line) {
	for ( var j = 0; j < walls.length; j++ ) { 
		var intersection = checkLineIntersection(line, walls[j]);
		if ( intersection.onLine1 && intersection.onLine2 ) return false; 
	}
	return true;
}

setInterval(function () { update(); render(); }, 20);
</script>

<p>Use the arrow keys to move; use the X key to dash.</p>

</body></html>
